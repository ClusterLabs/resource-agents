#!/bin/sh
#
#
# Support:      linux-ha@lists.linux-ha.org
# License:      GNU General Public License (GPL)
#
#	Resource Agent for the Xen Hypervisor.
#	Manages Xen virtual machine instances by
#	mapping cluster resource start and stop,  
#	to Xen create and shutdown, respectively.
#
#	usage: $0  {start|stop|status|monitor|meta-data}
#
#	  OCF parameters are as below:
#		OCF_RESKEY_xmfile
#			Absolute path to the Xen control file,
#			for this virtual machine.
#		OCF_RESKEY_allow_mem_management
#			Change memory usage on start/stop/migration
#			of virtual machine
#		OCF_RESKEY_reserved_Dom0_memory
#			minimum memory reserved for domain 0
#		OCF_RESKEY_monitor_scripts
#			scripts to monitor services within the
#			virtual domain

#######################################################################
# Initialization:

: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}
. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs

#######################################################################


usage() {
  cat <<-!
	usage: $0 {start|stop|status|monitor|meta-data|validate-all}
	!
}


: ${OCF_RESKEY_xmfile=/etc/xen/vm/MyDomU}
: ${OCF_RESKEY_allow_mem_management=0}
: ${OCF_RESKEY_reserved_Dom0_memory=512}

meta_data() {
	cat <<END
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="Xen">
<version>1.0</version>

<longdesc lang="en">
Resource Agent for the Xen Hypervisor.
Manages Xen virtual machine instances by mapping cluster resource
start and stop,  to Xen create and shutdown, respectively.

A note on names

We will try to extract the name from the config file (the xmfile
attribute). If you use a simple assignment statement, then you
should be fine. Otherwise, if there's some python acrobacy
involved such as dynamically assigning names depending on other
variables, and we will try to detect this, then please set the
name attribute. You should also do that if there is any chance of
a pathological situation where a config file might be missing,
for example if it resides on a shared storage. If all fails, we
finally fall back to the instance id to preserve backward
compatibility.

Para-virtualized guests can also be migrated by enabling the
meta_attribute allow-migrate.

</longdesc>
<shortdesc lang="en">Manages Xen unprivileged domains (DomUs)</shortdesc>

<parameters>

<parameter name="xmfile" unique="0" required="1">
<longdesc lang="en">
Absolute path to the Xen control file,
for this virtual machine.
</longdesc>
<shortdesc lang="en">Xen control file</shortdesc>
<content type="string" default="" />
</parameter>
<parameter name="name" unique="0" required="0">
<longdesc lang="en">
Name of the virtual machine.
</longdesc>
<shortdesc lang="en">Xen DomU name</shortdesc>
<content type="string" default="" />
</parameter>
<parameter name="shutdown_timeout">
<longdesc lang="en">
The Xen agent will first try an orderly shutdown using xm shutdown.
Should this not succeed within this timeout, the agent will escalate to
xm destroy, forcibly killing the node.

If this is not set, it will default to two-third of the stop action
timeout.

Setting this value to 0 forces an immediate destroy.

</longdesc>
<shortdesc lang="en">Shutdown escalation timeout</shortdesc>
<content type="string" default="" />
</parameter>
<parameter name="allow_mem_management" unique="0" required="0">
<longdesc lang="en">
This parameter enables dynamic adjustment of memory for start 
and stop actions used for Dom0 and the DomUs. The default is
to not adjust memory dynamically.
</longdesc>
<shortdesc lang="en">Use dynamic memory management</shortdesc>
<content type="boolean" default="0" />
</parameter>

<parameter name="node_ip_attribute">
<longdesc lang="en">
In case of a live migration, the system will default to using the IP
address associated with the hostname via DNS or /etc/hosts.

This parameter allows you to specify a node attribute that will be
queried instead for the target node, overriding the IP address. This
allows you to use a dedicated network for live migration traffic to a
specific node.

Warning: make very sure the IP address does point to the right node. Or
else the live migration will end up somewhere else, greatly confusing
the cluster and causing havoc.
</longdesc>
<shortdesc lang="en">Node attribute containing target IP address</shortdesc>
<content type="string" default="" />
</parameter>

<parameter name="reserved_Dom0_memory" unique="0" required="0">
<longdesc lang="en">
In case memory management is used, this parameter
defines the minimum amount of memory to be reserved
for the dom0. The default minimum memory is 512MB.
</longdesc>
<shortdesc lang="en">Minimum Dom0 memory</shortdesc>
<content type="string" default="512" />
</parameter>
<parameter name="monitor_scripts" unique="0" required="0">
<longdesc lang="en">
To additionally monitor services within the unprivileged domain,
add this parameter with a list of scripts to monitor.
</longdesc>
<shortdesc lang="en">list of space separated monitor scripts</shortdesc>
<content type="string" default="" />
</parameter>

</parameters>

<actions>
<action name="start" timeout="60" />
<action name="stop" timeout="40" />
<action name="migrate_from" timeout="120" />
<action name="migrate_to" timeout="120" />
<action name="monitor" depth="0" timeout="30" interval="10" />
<action name="meta-data" timeout="5" />
<action name="validate-all" timeout="5" />
</actions>
</resource-agent>
END
}

Xen_Status() {
  if have_binary xen-list; then
     xen-list $1 2>/dev/null | grep -qs "State.*[-r][-b][-p]--" 2>/dev/null
     if [ $? -ne 0 ]; then
     	return $OCF_NOT_RUNNING
     else
     	return $OCF_SUCCESS
     fi
  fi
  STATUS=`xm list --long $1 2>/dev/null | grep status 2>/dev/null`
  if [ "X${STATUS}" != "X" ]; then
    # we have Xen 3.0.4 or higher
    STATUS_NOSPACES=`echo "$STATUS" | awk '{ print $1,$2}'`
    if [ "$STATUS_NOSPACES" = "(status 2)" -o "$STATUS_NOSPACES" = "(status 1)" ]; then
      return $OCF_SUCCESS
    else 
      return $OCF_NOT_RUNNING
    fi
  else
    # we have Xen 3.0.3 or lower
    STATUS=`xm list --long $1 2>/dev/null | grep state 2>/dev/null`
    echo "${STATUS}" | grep -qs "[-r][-b][-p]---"
    if [ $? -ne 0 ]; then
      return $OCF_NOT_RUNNING
    else
      return $OCF_SUCCESS
    fi
    
  fi
}

Xen_Adjust_Memory() {
    if ocf_is_true "${OCF_RESKEY_allow_mem_management}"; then
      CNTNEW=$1
      RUNNING=`Xen_List_running`
      RUNCNT=`Xen_Count_running`
      MAXMEM=`Xen_Total_Memory`
      if [ ${RUNCNT} -eq 0 -a ${CNTNEW} -eq 0 ]; then
	RUNCNT=1
      fi
      #NEWMEM=`echo "(${MAXMEM}-${OCF_RESKEY_reserved_Dom0_memory})/(${RUNCNT}+${CNTNEW})"|bc`
      NEWMEM=$(( (${MAXMEM} - ${OCF_RESKEY_reserved_Dom0_memory}) / (${RUNCNT} + ${CNTNEW} ) ))
      # do not rely on ballooning add dom0_mem=512 instead to force memory for dom0
      #xm mem-set Domain-0 ${OCF_RESKEY_reserved_Dom0_memory}
      for DOM in ${RUNNING}; do
        xm mem-set ${DOM} ${NEWMEM} 
      done
      ocf_log info "Adjusted memory to: $NEWMEM, for the following $RUNCNT domains: $RUNNING"
    fi
}

Xen_List_all() {
	xm list | grep -v -e "Name" -e "Domain-0" | awk '{print $1}'
}
Xen_List_running() {
	ALL_DOMS=`Xen_List_all`
	for DOM in ${ALL_DOMS}; do
		if Xen_Status $DOM; then
			echo "${DOM} "
		fi
	done
}
Xen_Count_running() {
	Xen_List_running | wc -w
}

Xen_Monitor() {
  Xen_Status ${DOMAIN_NAME}
  if [ $? -eq ${OCF_NOT_RUNNING} ]; then
	return ${OCF_NOT_RUNNING}
  fi
  if [ "X${OCF_RESKEY_monitor_scripts}" = "X" ]; then
	return ${OCF_SUCCESS}
  fi
  for SCRIPT in ${OCF_RESKEY_monitor_scripts}; do
	$SCRIPT
	if [ $? -ne 0 ]; then
		return ${OCF_ERR_GENERIC}
	fi
  done
  return ${OCF_SUCCESS}
}

Xen_Total_Memory() {
	xm info | grep "^total_memory" | awk '{print $3}'
}

Xen_Start() {
  if Xen_Status ${DOMAIN_NAME}; then
    ocf_log info "Xen domain $DOMAIN_NAME already running."
    return $OCF_SUCCESS
  fi

  if [ ! -f "${OCF_RESKEY_xmfile}" ]; then
    ocf_log err "Config file ${OCF_RESKEY_xmfile} for $DOMAIN_NAME does not exist."
    return $OCF_ERR_INSTALLED
  fi

  if ocf_is_true "${OCF_RESKEY_allow_mem_management}"; then
    Xen_Adjust_Memory 1
    ocf_log info "New memory for virtual domains: ${NEWMEM}"
    sed -i -e "/^memory=/ s/^memory=.*/memory=${NEWMEM}/" ${OCF_RESKEY_xmfile}
    xm mem-set ${DOMAIN_NAME} ${NEWMEM} 
  fi

  xm create ${OCF_RESKEY_xmfile} name=$DOMAIN_NAME
  rc=$?
  if [ $rc -ne 0 ]; then
    return $OCF_ERR_GENERIC
  else 
    if ocf_is_true "${OCF_RESKEY_allow_mem_management}"; then
      xm mem-set ${DOMAIN_NAME} ${NEWMEM}
    fi
  fi
  while sleep 1; do
    Xen_Monitor && return $OCF_SUCCESS
  done
}

xen_domain_stop() {
    local dom=$1
    local timeout

    if [ -n "$OCF_RESKEY_shutdown_timeout" ]; then
      timeout=$OCF_RESKEY_shutdown_timeout
    elif [ -n "$OCF_RESKEY_CRM_meta_timeout" ]; then
      # Allow 2/3 of the action timeout for the orderly shutdown
      # (The origin unit is ms, hence the conversion)
      timeout=$((OCF_RESKEY_CRM_meta_timeout/1500))
    else
      timeout=60
    fi

    if [ "$timeout" -gt 0 ]; then
      ocf_log info "Xen domain $dom will be stopped (timeout: ${timeout}s)"
      xm shutdown $dom
          
      while Xen_Status $dom && [ "$timeout" -gt 0 ]; do
        ocf_log debug "$dom still not stopped. Waiting..."
        timeout=$((timeout-1))
        sleep 1
      done
    fi
    
    if [ "$timeout" -eq 0 ]; then
      while Xen_Status $dom; do
        ocf_log warn "Xen domain $dom will be destroyed!"
	$xenkill $dom
        sleep 1
      done
      # Note: This does not give up. stop isn't allowed to to fail.
      # If xm destroy fails, stop will eventually timeout.
      # This is the correct behaviour.
    fi

    ocf_log info "Xen domain $dom stopped."
}

Xen_Stop() {
  local vm
  if Xen_Status ${DOMAIN_NAME}; then
    vm=${DOMAIN_NAME}
  elif Xen_Status migrating-${DOMAIN_NAME}; then
    ocf_log info "Xen domain $DOMAIN_NAME is migrating" 
    vm="migrating-${DOMAIN_NAME}"
  else
    ocf_log info "Xen domain $DOMAIN_NAME already stopped." 
  fi

  if [ "$vm" ]; then
    xen_domain_stop $vm
  else
  # It is supposed to be gone, but there have been situations where xm
  # list / xen-list showed it as stopped but it was still instantiated.
  # Nuke it once more to make sure:
    $xenkill ${DOMAIN_NAME}
  fi

  Xen_Adjust_Memory 0
  return $OCF_SUCCESS
}

Xen_Migrate_To() {
  target_node="$OCF_RESKEY_CRM_meta_migrate_target"
  target_attr="$OCF_RESKEY_CRM_node_ip_attribute"
  target_addr="$target_node"
 
  if Xen_Status ${DOMAIN_NAME}; then
    ocf_log info "$DOMAIN_NAME: Starting xm migrate to $target_node"
    
    if [ -n "$target_attr" ]; then
	  nodevalue=`crm_attribute --type nodes --node-uname $target_node --attr-name $target_attr --get-value -q`
	  if [ -n "${nodevalue}" -a "${nodevalue}" != "(null)" ]; then
	  	target_addr="$nodevalue"
		ocf_log info "$DOMAIN_NAME: $target_node is using address $target_addr"
	  fi
    fi

    xm migrate --live $DOMAIN_NAME $target_addr

    rc=$?
    if [ $rc -ne 0 ]; then
      ocf_log err "$DOMAIN_NAME: xm migrate to $target_node failed: $rc"
      return $OCF_ERR_GENERIC
    else 
      Xen_Adjust_Memory 0
      ocf_log info "$DOMAIN_NAME: xm migrate to $target_node succeeded."
      return $OCF_SUCCESS
    fi
  else
    ocf_log err "$DOMAIN_NAME: migrate_to: Not active locally!"
    return $OCF_ERR_GENERIC
  fi
}

Xen_Migrate_From() {
  if [ -n "$OCF_RESKEY_CRM_meta_timeout" ]; then
      # Allow 2/3 of the action timeout for status to stabilize
      # (The origin unit is ms, hence the conversion)
      timeout=$((OCF_RESKEY_CRM_meta_timeout/1500))
  else
      timeout=10		# should be plenty
  fi

  while ! Xen_Status ${DOMAIN_NAME} && [ $timeout -gt 0 ]; do
    ocf_log debug "$DOMAIN_NAME: Not yet active locally, waiting (timeout: ${timeout}s)"
    timeout=$((timeout-1))
    sleep 1
  done

  if Xen_Status ${DOMAIN_NAME}; then
    Xen_Adjust_Memory 0
    ocf_log info "$DOMAIN_NAME: Active locally, migration successful"
    return $OCF_SUCCESS
  else
    ocf_log err "$DOMAIN_NAME: Not active locally, migration failed!"
    return $OCF_ERR_GENERIC
  fi
}

Xen_Validate_All() {
  return $OCF_SUCCESS
}

if [ $# -ne 1 ]; then
  usage
  exit $OCF_ERR_ARGS
fi

case $1 in
  meta-data)		meta_data
			exit $OCF_SUCCESS
			;;
  usage)		usage
			exit $OCF_SUCCESS
			;;
esac

# the name business:
#
# 1. use the name attribute, or
# 2. find the name in the config file (if it exists) and use that
# unless it contains funny characters such as '%' or space, or
# 3. use the OCF_RESOURCE_INSTANCE

if [ x"${OCF_RESKEY_name}" != x ]; then
	DOMAIN_NAME="${OCF_RESKEY_name}"
else
	if [ -f "${OCF_RESKEY_xmfile}" ]; then
		DOMAIN_NAME=`awk '$1~/^name(=|$)/{print}' ${OCF_RESKEY_xmfile} | sed 's/.*=[[:space:]]*//' | tr -d "[\"']"`
		if echo "$DOMAIN_NAME" | grep -qs '[%[:space:]]'; then
			DOMAIN_NAME=""
		fi
	fi
	DOMAIN_NAME=${DOMAIN_NAME:-${OCF_RESOURCE_INSTANCE}}
fi

for binary in xm sed awk; do
    check_binary $binary
done

if have_binary xen-destroy ; then
  xenkill="xen-destroy"
else
  xenkill="xm destroy"
fi

if [ -n "$OCF_RESKEY_shutdown_timeout" ]; then
	ocf_is_decimal "$OCF_RESKEY_shutdown_timeout" || {
		ocf_log err "shutdown_timeout must be a number" 
		exit $OCF_ERR_CONFIGURED
	}
fi

case $1 in
  start)		Xen_Start
			;;
  stop)			Xen_Stop
			;;
  migrate_to)		Xen_Migrate_To
			;;
  migrate_from)		Xen_Migrate_From
			;;
  monitor)		Xen_Monitor
			;;
  status)		Xen_Status ${DOMAIN_NAME}
			;;
  validate-all)		Xen_Validate_All
			;;
  *)			usage
			exit $OCF_ERR_UNIMPLEMENTED
			;;
esac
exit $?

