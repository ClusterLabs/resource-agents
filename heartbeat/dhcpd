#!/bin/sh
#
#   Resource Agent for managing dhcpd resources.
#
#   License:      GNU General Public License (GPL)
#   (c) 2011-2012 Chris Bowlby,
#                 and Linux-HA contributors

# Initialization:
: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}
. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs

# Defaults
OCF_RESKEY_binary_default="dhcpd"
OCF_RESKEY_pid_default="/var/run/dhcpd.pid"
OCF_RESKEY_user_default=dhcpd
OCF_RESKEY_group_default=nogroup
OCF_RESKEY_config_default=""
OCF_RESKEY_chrooted_path_default="/var/lib/dhcp"
OCF_RESKEY_leases_default="/db/dhcpd.leases"
OCF_RESKEY_interface_default=""

: ${OCF_RESKEY_binary=${OCF_RESKEY_binary_default}}
: ${OCF_RESKEY_pid=${OCF_RESKEY_pid_default}}
: ${OCF_RESKEY_user=${OCF_RESKEY_user_default}}
: ${OCF_RESKEY_group=${OCF_RESKEY_group_default}}
: ${OCF_RESKEY_chrooted_path=${OCF_RESKEY_chrooted_path_default}}
: ${OCF_RESKEY_config=${OCF_RESKEY_config_default}}
: ${OCF_RESKEY_leases=${OCF_RESKEY_leases_default}}
: ${OCF_RESKEY_interface=${OCF_RESKEY_interface_default}}


usage() {
    cat <<EOF
        usage: $0 start|stop|status|monitor|meta-data|validate-all

        $0 manages the dhcp (dhcpd) server as an HA resource.

        The 'start' operation starts the dhcpd server.
        The 'stop' operation stops the dhcpd server.
        The 'status' operation reports whether the dhcpd service is up.
        The 'monitor' operation reports whether the dhcpd service is running.
        The 'validate-all' operation reports whether the parameters are valid.
EOF
  return $OCF_SUCCESS
}

dhcpd_meta_data() {
        cat <<EOF
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="dhcpd" version="0.1">
  <version>0.1</version>
  <longdesc lang="en">
This is a resource agent configuration for the DHCP server
service.
  </longdesc>
  <shortdesc lang="en">DHCP Server resource agent.</shortdesc>
  <parameters>
    <parameter name="config" unique="1" required="1">
      <longdesc lang="en">
	The full path to the configuration file.
      </longdesc>
      <shortdesc lang="en">Configuration file</shortdesc>
      <content type="string" default="${OCF_RESKEY_config_default}"/>
    </parameter>
    <parameter name="chrooted_path" unique="1" required="0">
      <longdesc lang="en">
	The path for the chrooted daemon to run in
      </longdesc>
      <shortdesc lang="en">The chrooted path</shortdesc>
      <content type="string" default="${OCF_RESKEY_chrooted_path_default}"/>
    </parameter>
    <parameter name="binary" unique="0" required="0">
      <longdesc lang="en">
        The binary used to start DHCPD.
      </longdesc>
      <shortdesc lang="en">DHCPD binary</shortdesc>
      <content type="string" default="${OCF_RESKEY_binary_default}"/>
    </parameter>
    <parameter name="user" unique="0" required="0">
      <longdesc lang="en">
	Run the DHCP Server daemon as this user.
      </longdesc>
      <shortdesc lang="en">DHCPD owner</shortdesc>
      <content type="string" default="${OCF_RESKEY_user_default}"/>
    </parameter>
    <parameter name="group" unique="0" required="0">
      <longdesc lang="en">
        Run the DHCP Server daemon as this group.
      </longdesc>
      <shortdesc lang="en">DHCPD group owner</shortdesc>
      <content type="string" default="${OCF_RESKEY_group_default}"/>
    </parameter>
    <parameter name="interface" unique="0" required="0">
      <longdesc lang="en">
        The network interface to assign to DHCP
      </longdesc>
      <shortdesc lang="en">Network Interface</shortdesc>
      <content type="string" default="${OCF_RESKEY_interface_default}"/>
    </parameter>
    <parameter name="leases" unique="0" required="0">
      <longdesc lang="en">
        The DHCP Leases file
      </longdesc>
      <shortdesc lang="en">Leases file</shortdesc>
      <content type="string" default="${OCF_RESKEY_leases_default}"/>
    </parameter>
    <parameter name="pid" unique="0" required="0">
      <longdesc lang="en">
        The DHCPD daemon PID file
      </longdesc>
      <shortdesc lang="en">PID file</shortdesc>
      <content type="string" default="${OCF_RESKEY_pid_default}"/>
    </parameter>
  </parameters>
  <actions>
    <action name="start"        timeout="20" />
    <action name="stop"         timeout="20" />
    <action name="monitor"      timeout="20" interval="10" depth="0" />
    <action name="meta-data"    timeout="5" />
    <action name="validate-all"   timeout="20" />
  </actions>
</resource-agent>
EOF
}

# Validate most critical parameters
dhcpd_validate_all() {
    ocf_log debug "Validating the ${OCF_RESKEY_binary} binary exists."
    check_binary ${OCF_RESKEY_binary}


    if ! ocf_is_probe; then
	ocf_log debug "Validating the chrooted path exists"
	if ! test -e "${OCF_RESKEY_chrooted_path}"; then
	    ocf_log err "Path ${OCF_RESKEY_chrooted_path} does not exist."
	    return $OCF_ERR_INSTALLED
	fi

	ocf_log debug "Checking to see if the ${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_config} exists and is readable"
	if test -n "${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_config}" -a ! -r "${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_config}"; then
	    ocf_log err "Configuration file ${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_config} doesn't exist"
	    return $OCF_ERR_INSTALLED
	fi
    else
	ocf_log info "${OCF_RESKEY_chrooted_path} not readable during probe."
    fi 

    ocf_log debug "Validating the ${OCF_RESKEY_user} user exists"
    getent passwd ${OCF_RESKEY_user} >/dev/null 2>&1
    if ! test $? -eq 0; then
        ocf_log err "User ${OCF_RESKEY_user} doesn't exist";
        return $OCF_ERR_INSTALLED
    fi

    ocf_log debug "Validation complete, everything looks good."

    return $OCF_SUCCESS
}

# dhcpd_status. Simple check of the status of dhcpd process by pid.
dhcpd_status () {
    ocf_pidfile_status ${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_pid} >/dev/null 2>&1
}

# dhcpd_monitor. Send a request to dhcpd and check response.
dhcpd_monitor() {
    local output

    ocf_log debug "Testing the state of the daemon itself"
    if ! dhcpd_status
    then
        ocf_log info "The dhcpd process is not running"
        return $OCF_NOT_RUNNING
    fi

    return $OCF_SUCCESS
}

# Start
dhcpd_start() {
    # Lets make sure we are not already running.
    dhcpd_monitor && return $OCF_SUCCESS

    ## If there is a pid file containing a pid, the machine might have crashed. pid files in
    ## /var/run are always cleaned up at boot time, but this is not the case for the pid file in
    ## the chroot jail. Therefore, an old pid file may exist. This is only a problem if it
    ## incidentally contains the pid of a running process. If this process is not a 'dhcpd',
    ## we remove the pid. (dhcpd itself only checks whether the pid is alive or not.)
    ocf_log debug "Removing ${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_pid} if it exists because the DHCPD process is not running."
    test -e "${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_pid}" && rm -f ${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_pid}

    ## If there is no conf file, skip starting up dhcpd
    ## and return with "program not configured"
    ocf_log debug "Re-validating the ${OCF_RESKEY_config} exists."
    if ! [ -f ${OCF_RESKEY_config} ]; then
	ocf_log err "dhcpd has not been configured."
	return $OCF_ERR_CONFIGURED
    fi

    ocf_log debug "Creating the ${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_leases} file if it does not already exist."
    if [ ! -e ${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_leases} ]; then
	# If the leases file does not exist, create it, as this is a fresh install.
	touch ${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_leases}
    fi

    # Remove the random device.
    ocf_log debug "Removing the old ${OCF_RESKEY_chrooted_path}/dev/urandom device."
    test -e "${OCF_RESKEY_chrooted_path}/dev/urandom" && rm -f ${OCF_RESKEY_chrooted_path}/dev/urandom

    # Ensure all "modified" non-chrooted configuration files are copied into the chrooted environment.
    ocf_log debug "Ensuring all chrooted paths are created, and the required configuration files are copied into place."
    for i in ${OCF_RESKEY_config} /etc/gai.conf /etc/nsswitch.conf /etc/resolv.conf /etc/host.conf /etc/hosts /etc/localtime /dev/urandom; do
	# First, lets make sure the directory exists within the chrooted environment.
	if test -d "${i}" ; then
	    test -d "${OCF_RESKEY_chrooted_path}/${i}" || mkdir -p "${OCF_RESKEY_chrooted_path}/${i}"
	elif test -e "${i}" ; then
	    test -d "${OCF_RESKEY_chrooted_path}/${i%/*}" || mkdir -p "${OCF_RESKEY_chrooted_path}/${i%/*}"
	fi

	# Next, we copy the configuration file into place.
	cp -aL "$i" "${OCF_RESKEY_chrooted_path}/${i%/*}/" > /dev/null 2>&1 || { ocf_log err "could not copy $i to chroot jail"; return $OCF_ERR_GENERIC; }
    done

    ocf_log debug "Validating all libraries and sub-dependencies are in place."
    libdir=$(basename $(echo /var/lib/dhcp/lib*))
    if test -x /usr/bin/ldd ; then
	get_ldd_deps()
	{
	    ldd_wl="\/${libdir}\/lib"
	    ldd_bl="\/${libdir}\/libc\."
	    /usr/bin/ldd "$1" | while read a b c d ; do
		[ -n "$c" ] || continue
		[ $c =~ $ldd_wl ] || continue
		[ $c =~ $ldd_bl ] && continue
		echo $c
	    done
	}
    else
	get_ldd_deps() { :; }
    fi
    cplibs=`for i in "/$libdir/libresolv.so.* /$libdir/libnss_*.so.* /$libdir/libpthread.so.0 /$libdir/libdl.so.2" ;
    do
	if [ -s "$i" ] ; then
	    echo "$i"
	    get_ldd_deps "$i"
	fi
    done | sort -u`
    for i in $cplibs ; do
	if [ -s "$i" ]; then
	    cp -pL "$i" "/var/lib/dhcp/$libdir/" || { ocf_log err "could not copy $i to chroot jail"; return $OCF_ERR_GENERIC; }
	fi
    done

    DHCPD_ARGS="-chroot ${OCF_RESKEY_chrooted_path} -lf ${OCF_RESKEY_leases}"

    if [ -n "${OCF_RESKEY_user}" ]; then
	DHCPD_ARGS="$DHCPD_ARGS -user ${OCF_RESKEY_user}"
    fi
    if [ -n "${OCF_RESKEY_group}" ]; then
	DHCPD_ARGS="$DHCPD_ARGS -group ${OCF_RESKEY_group}"
    fi

    ocf_run ${OCF_RESKEY_binary} -cf ${OCF_RESKEY_config} $DHCPD_ARGS -pf ${OCF_RESKEY_pid} ${OCF_RESKEY_interface} || return $OCF_NOT_RUNNING

    ocf_log info "dhcpd [chrooted] has started."

    return $OCF_SUCCESS
}

# Stop
dhcpd_stop () {
    local timeout
    local timewait
    local rc

    dhcpd_monitor
    rc=$?

    case "${rc}" in
	"$OCF_SUCCESS")
	    # Currently running, and is expected behaviour.
	    ocf_log debug "The resource is currently running."
	    ;;
	"$OCF_RUNNING_MASTER")
	    # Running as a master (currently not yet supported in this script).
	    ocf_log debug "Resource is currently running as a master."
	    # TODO: Add code to demote self
	    ;;
	"$OCF_NOT_RUNNING")
	    # Currently not running, therefore nothing to do.
	    ocf_log info "Resource has already been stopped."
	    return $OCF_SUCCESS
	    ;;
    esac

    kill `cat ${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_pid}`

    # Allow 2/3 of the action timeout for the orderly shutdown
    # (The origin unit is ms, hence the conversion)
    timewait=$((OCF_RESKEY_CRM_meta_timeout/1500))

    sleep 1; timeout=0 # Sleep here for 1 sec to let dhcpd finish.
    while dhcpd_monitor ; do
        if [ $timeout -ge $timewait ]; then
            break
        else
            sleep 1
            timeout=`expr $timeout + 1`
            ocf_log debug "dhcpd appears to hung, waiting ..."
        fi
    done

    #If still up
    if dhcpd_monitor 2>&1; then
        ocf_log err "dhcpd is still up! Killing"
        kill -s SIGKILL `cat ${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_pid}`
    fi

    rm -f ${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_pid}
    return $OCF_SUCCESS
}

# Make sure meta-data and usage always succeed
case $__OCF_ACTION in
meta-data)      dhcpd_meta_data
                exit $OCF_SUCCESS
                ;;
validate-all)   dhcpd_validate_all
		exit $OCF_SUCCESS
		;;
usage|help)     dhcpd_usage
                exit $OCF_SUCCESS
                ;;
esac

# Anything other than meta-data and usage must pass validation
dhcpd_validate_all || exit $?

# Translate each action into the appropriate function call
case $__OCF_ACTION in
meta-data)      dhcpd_meta_data;;
start)          dhcpd_start;;
stop)           dhcpd_stop;;
status|monitor) dhcpd_monitor;;
*)              dhcpd_usage
                exit $OCF_ERR_UNIMPLEMENTED
                ;;
esac
rc=$?

ocf_log debug "Resource Agent Exit Status $rc"
# The resource agent may optionally log a debug message
ocf_log debug "${OCF_RESOURCE_INSTANCE} $__OCF_ACTION returned $rc"
exit $rc
