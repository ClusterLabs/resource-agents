#!/bin/sh
#
#   Resource Agent for managing dhcpd resources.
#
#   License:      GNU General Public License (GPL)
#   (c) 2011-2011 Chris Bowlby,
#                 and Linux-HA contributors

# Initialization:
: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}
. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs

# Defaults
OCF_RESKEY_binary_default="dhcpd"
OCF_RESKEY_pid_default="/var/run/dhcpd.pid"
OCF_RESKEY_user_default=dhcpd
OCF_RESKEY_group_default=nogroup
OCF_RESKEY_config_default=""
OCF_RESKEY_chrooted_path_default="/var/lib/dhcp"
OCF_RESKEY_leases_default="/db/dhcpd.leases"
OCF_RESKEY_interface_default=""
OCF_RESKEY_includes_default=""

: ${OCF_RESKEY_binary=${OCF_RESKEY_binary_default}}
: ${OCF_RESKEY_pid=${OCF_RESKEY_pid_default}}
: ${OCF_RESKEY_user=${OCF_RESKEY_user_default}}
: ${OCF_RESKEY_group=${OCF_RESKEY_group_default}}
: ${OCF_RESKEY_chrooted_path=${OCF_RESKEY_chrooted_path_default}}
: ${OCF_RESKEY_config=${OCF_RESKEY_config_default}}
: ${OCF_RESKEY_leases=${OCF_RESKEY_leases_default}}
: ${OCF_RESKEY_interface=${OCF_RESKEY_interface_default}}
: ${OCF_RESKEY_includes=${OCF_RESKEY_includes_default}}

# To enable support for different versions of dhcp, we need
# to know what version we are being run against.
DHCP_VERSION_MAJOR=`${OCF_RESKEY_binary} --version 2>&1 | awk -F- '{print $3}' | awk -F.  '{print $1}'`

# These files are always copied by default to ensure the chroot environment works.
DEFAULT_FILE_LIST="/etc/gai.conf /etc/nsswitch.conf /etc/resolv.conf /etc/host.conf /etc/hosts /etc/localtime /dev/urandom"

usage() {
    cat <<EOF
        usage: $0 start|stop|status|monitor|meta-data|validate-all

        $0 manages the dhcp (dhcpd) server as an HA resource.

        The 'start' operation starts the dhcpd server.
        The 'stop' operation stops the dhcpd server.
        The 'status' operation reports whether the dhcpd service is up.
        The 'monitor' operation reports whether the dhcpd service is running.
        The 'validate-all' operation reports whether the parameters are valid.
EOF
  return $OCF_SUCCESS
}

dhcpd_meta_data() {
        cat <<EOF
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="dhcpd" version="0.1">
  <version>0.1</version>
  <longdesc lang="en">
This is a resource agent designed for a chrooted DHCP server
service.
  </longdesc>
  <shortdesc lang="en">Chrooted DHCP Server resource agent.</shortdesc>
  <parameters>
    <parameter name="config" unique="1" required="1">
      <longdesc lang="en">
	This parameter represents the full path to the DHCP server
	configuration file. For example, /etc/dhcpd.conf.
      </longdesc>
      <shortdesc lang="en">Configuration file</shortdesc>
      <content type="string" default="${OCF_RESKEY_config_default}"/>
    </parameter>
    <parameter name="chrooted_path" unique="1" required="0">
      <longdesc lang="en">
	This parameter defines the full path where the chrooted DHCP
	server process will operate.
      </longdesc>
      <shortdesc lang="en">The chrooted path</shortdesc>
      <content type="string" default="${OCF_RESKEY_chrooted_path_default}"/>
    </parameter>
    <parameter name="binary" unique="0" required="0">
      <longdesc lang="en">
        This parameter defines the executable binary for the DHCP 
	server process. A full path definition is not required, but
	can be used to override environmental path values.
      </longdesc>
      <shortdesc lang="en">DHCPD binary</shortdesc>
      <content type="string" default="${OCF_RESKEY_binary_default}"/>
    </parameter>
    <parameter name="user" unique="0" required="0">
      <longdesc lang="en">
	This parameter defines the system user the DHCP server
	process will use when it is chrooted. This helps to limit
	possible issues in the event a DHCP server process is compromised.
      </longdesc>
      <shortdesc lang="en">DHCPD owner</shortdesc>
      <content type="string" default="${OCF_RESKEY_user_default}"/>
    </parameter>
    <parameter name="group" unique="0" required="0">
      <longdesc lang="en">
	This parameter defines the system group the DHCP server
	process will use when it is chrooted. This helps to limit
	possible issues in the event a DHCP server process is compromised.
      </longdesc>
      <shortdesc lang="en">DHCPD group owner</shortdesc>
      <content type="string" default="${OCF_RESKEY_group_default}"/>
    </parameter>
    <parameter name="interface" unique="0" required="0">
      <longdesc lang="en">
	This parameter defines the network interface(s) the DHCP
	server process will bind to. A blank value will bind the 
	process to all interfaces.
      </longdesc>
      <shortdesc lang="en">Network Interface</shortdesc>
      <content type="string" default="${OCF_RESKEY_interface_default}"/>
    </parameter>
    <parameter name="includes" unique="0" required="0">
      <longdesc lang="en">
	This parameter provides a means for an admin to copy include
	files into the chrooted environment. If a dhcpd.conf file
	contains a line similar to the this:

		include "/etc/named.keys";

	Then an admin also has to tell the dhcpd ra script that this
	file should be pulled into the chrooted environment. This is
	a space delimited list.
      </longdesc>
      <shortdesc lang="en">Include Files</shortdesc>
      <content type="string" default="${OCF_RESKEY_includes_default}"/>
    </parameter>
    <parameter name="leases" unique="0" required="0">
      <longdesc lang="en">
	This parameter defines the leases database file, from
	the view point of the chrooted location. For example, 
	if your chrooted_path = "/var/lib/dhcp", and your lease
	file is to be stored in "/var/lib/dhcp/db/dhcpd.leases", you
	would simply set the parameter to "/db/dhcpd.leases".
      </longdesc>
      <shortdesc lang="en">Leases file</shortdesc>
      <content type="string" default="${OCF_RESKEY_leases_default}"/>
    </parameter>
    <parameter name="pid" unique="0" required="0">
      <longdesc lang="en">
	This parameter defines the path and filename of the PID file.
	It is used from the viewpoint of the chrooted_path parameter,
	such that a parameter value of "/var/run/dhcpd.pid" will store
	the file in "/var/lib/dhcp/var/run/dhcpd.pid" if the 
	chrooted_path parameter is configured as "/var/lib/dhcp".
      </longdesc>
      <shortdesc lang="en">PID file</shortdesc>
      <content type="string" default="${OCF_RESKEY_pid_default}"/>
    </parameter>
  </parameters>
  <actions>
    <action name="start"        timeout="20" />
    <action name="stop"         timeout="20" />
    <action name="monitor"      timeout="20" interval="10" depth="0" />
    <action name="meta-data"    timeout="5" />
    <action name="validate-all"   timeout="20" />
  </actions>
</resource-agent>
EOF
}

# Validate most critical parameters
dhcpd_validate_all() {
    ocf_log debug "Validating the ${OCF_RESKEY_binary} binary exists."
    check_binary ${OCF_RESKEY_binary}


    if ! ocf_is_probe; then
	ocf_log debug "Validating the chrooted path exists"
	if ! test -e "${OCF_RESKEY_chrooted_path}"; then
	    ocf_log err "Path ${OCF_RESKEY_chrooted_path} does not exist."
	    return $OCF_ERR_INSTALLED
	fi

	ocf_log debug "Checking to see if the ${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_config} exists and is readable"
	if test -n "${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_config}" -a ! -r "${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_config}"; then
	    ocf_log err "Configuration file ${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_config} doesn't exist"
	    return $OCF_ERR_INSTALLED
	fi
    else
	ocf_log info "${OCF_RESKEY_chrooted_path} not readable during probe."
    fi 

    ocf_log debug "Validating the ${OCF_RESKEY_user} user exists"
    getent passwd ${OCF_RESKEY_user} >/dev/null 2>&1
    if ! test $? -eq 0; then
        ocf_log err "User ${OCF_RESKEY_user} doesn't exist";
        return $OCF_ERR_INSTALLED
    fi

    ocf_log debug "Validation complete, everything looks good."

    return $OCF_SUCCESS
}

# dhcpd_status. Simple check of the status of dhcpd process by pid.
dhcpd_status () {
    ocf_pidfile_status ${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_pid} >/dev/null 2>&1
}

# dhcpd_monitor. Send a request to dhcpd and check response.
dhcpd_monitor() {
    local output

#    ocf_log debug "Testing the state of the daemon itself"
    if ! dhcpd_status
    then
        ocf_log info "The dhcpd process is not running"
        return $OCF_NOT_RUNNING
    fi

    return $OCF_SUCCESS
}

# Initialize Chroot
dhcpd_initialize_chroot() {
    # If we are running the initialization for the first time, we need to make
    # the new chrooted folder, in case we are not using the same default.
    if ! [ -d ${OCF_RESKEY_chrooted_path} ] ; then
	ocf_log info "Initializing ${OCF_RESKEY_chrooted_path} for use."
	mkdir -p ${OCF_RESKEY_chrooted_path}
    fi

    # Make sure all sub-paths are created if something went wrong during
    # a partial run.
    for i in "db dev etc lib64 var" ; do
	if ! [ -d ${OCF_RESKEY_chrooted_path}/${i} ] ; then
	    mkdir -p ${OCF_RESKEY_chrooted_path}/${i}
	fi
    done

    if ! [ -d ${OCF_RESKEY_chrooted_path}/var/run ] ; then
	mkdir -p ${OCF_RESKEY_chrooted_path}/var/run
    fi

    ocf_log debug "making sure we are not running version 4 or higher"
    # If we are running version 4 of the dhcp server, we need to mount a proc partition.
    if [ ${DHCP_VERSION_MAJOR} -ge 4 ] ; then
	ocf_log debug "we are."
	if ! [ -d ${OCF_RESKEY_chrooted_path}/proc ] ; then
	    mkdir -p ${OCF_RESKEY_chrooted_path}/proc
	fi

	if ! [ -e ${OCF_RESKEY_chrooted_path}/proc/net/dev ] ; then
	    mount -t proc -o ro proc ${OCF_RESKEY_chrooted_path}/proc > /dev/null 2>&1
	fi
    fi

    # Ensure all permissions are in place if the folder was re-created.
    chown -R ${OCF_RESKEY_user}:${OCF_RESKEY_group} ${OCF_RESKEY_chrooted_path}/`dirname ${OCF_RESKEY_leases}`
    chown -R ${OCF_RESKEY_user}:${OCF_RESKEY_group} ${OCF_RESKEY_chrooted_path}/`dirname ${OCF_RESKEY_pid}`

    ## If there is no conf file, we can't initialize the chrooted 
    ## environment, return with "program not configured"
    if ! [ -f ${OCF_RESKEY_config} ] ; then
	ocf_log err "dhcpd has not been configured."
	return $OCF_ERR_CONFIGURED
    fi

    # If the leases file does not exist, create it, as this is a fresh install.
    if [ ! -e ${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_leases} ]; then
	touch ${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_leases}
    fi

    # Remove the random device.
    test -e "${OCF_RESKEY_chrooted_path}/dev/urandom" && rm -f ${OCF_RESKEY_chrooted_path}/dev/urandom

    # Test for the existance of the defined include files, and append
    # them to the list of files to be copied.
    for i in ${OCF_RESKEY_includes} ; do
	if [ -e ${i} ] ; then
		DEFAULT_FILE_LIST="${DEFAULT_FILE_LIST} ${i}"
	fi
    done

    # Ensure all "modified" non-chrooted configuration files are copied into the chrooted environment.
    for i in ${OCF_RESKEY_config} ${DEFAULT_FILE_LIST}; do
	# First, lets make sure the directory exists within the chrooted environment.
	if test -d "${i}" ; then
	    test -d "${OCF_RESKEY_chrooted_path}/${i}" || mkdir -p "${OCF_RESKEY_chrooted_path}/${i}"
	elif test -e "${i}" ; then
	    test -d "${OCF_RESKEY_chrooted_path}/${i%/*}" || mkdir -p "${OCF_RESKEY_chrooted_path}/${i%/*}"
	fi

	# Next, we copy the configuration file into place.
	cp -aL "$i" "${OCF_RESKEY_chrooted_path}/${i%/*}/" > /dev/null 2>&1 || { ocf_log err "could not copy $i to chroot jail"; return $OCF_ERR_GENERIC; }
    done

    libdir=$(basename $(echo /var/lib/dhcp/lib*))
    if test -x /usr/bin/ldd ; then
	get_ldd_deps()
	{
	    ldd_wl="\/${libdir}\/lib"
	    ldd_bl="\/${libdir}\/libc\."
	    /usr/bin/ldd "$1" | while read a b c d ; do
		[ -n "$c" ] || continue
		[ $c =~ $ldd_wl ] || continue
		[ $c =~ $ldd_bl ] && continue
		echo $c
	    done
	}
    else
	get_ldd_deps() { :; }
    fi
    cplibs=`for i in "/$libdir/libresolv.so.* /$libdir/libnss_*.so.* /$libdir/libpthread.so.0 /$libdir/libdl.so.2" ;
    do
	if [ -s "$i" ] ; then
	    echo "$i"
	    get_ldd_deps "$i"
	fi
    done | sort -u`
    for i in $cplibs ; do
	if [ -s "$i" ]; then
	    cp -pL "$i" "/var/lib/dhcp/$libdir/" || { ocf_log err "could not copy $i to chroot jail"; return $OCF_ERR_GENERIC; }
	fi
    done

   return $OCF_SUCCESS
}

# Start
dhcpd_start() {
    # Lets make sure we are not already running.
    dhcpd_monitor && return $OCF_SUCCESS

    ## If there is a pid file containing a pid, the machine might have crashed. pid files in
    ## /var/run are always cleaned up at boot time, but this is not the case for the pid file in
    ## the chroot jail. Therefore, an old pid file may exist. This is only a problem if it
    ## incidentally contains the pid of a running process. If this process is not a 'dhcpd',
    ## we remove the pid. (dhcpd itself only checks whether the pid is alive or not.)
    ocf_log info "Starting dhcpd [chroot] service."
    test -e "${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_pid}" && rm -f ${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_pid}

    # Re-run the initialization function to pull in any changes made to the non-chrooted files.
    dhcpd_initialize_chroot || { ocf_log err "Could not fully initialize the chroot environment." ; return $OCF_ERR_CONFIGURED; }

    DHCPD_ARGS="-chroot ${OCF_RESKEY_chrooted_path} -lf ${OCF_RESKEY_leases}"

    if [ -n "${OCF_RESKEY_user}" ]; then
	DHCPD_ARGS="$DHCPD_ARGS -user ${OCF_RESKEY_user}"
    fi
    if [ -n "${OCF_RESKEY_group}" ]; then
	DHCPD_ARGS="$DHCPD_ARGS -group ${OCF_RESKEY_group}"
    fi

    ocf_run ${OCF_RESKEY_binary} -cf ${OCF_RESKEY_config} $DHCPD_ARGS -pf ${OCF_RESKEY_pid} ${OCF_RESKEY_interface} || return $OCF_ERR_CONFIGURED

    ocf_log info "dhcpd [chrooted] has started."

    return $OCF_SUCCESS
}

# Stop
dhcpd_stop () {
    local timeout
    local timewait
    local rc

    dhcpd_monitor
    rc=$?

    case "${rc}" in
	"$OCF_SUCCESS")
	    # Currently running, and is expected behaviour.
#	    ocf_log debug "The resource is currently running."
	    ;;
	"$OCF_RUNNING_MASTER")
	    # Running as a master (currently not yet supported in this script).
#	    ocf_log debug "Resource is currently running as a master."
	    # TODO: Add code to demote self
	    ;;
	"$OCF_NOT_RUNNING")
	    # Currently not running, therefore nothing to do.
	    ocf_log info "Resource has already been stopped."
	    return $OCF_SUCCESS
	    ;;
    esac

    kill `cat ${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_pid}`

    # Allow 2/3 of the action timeout for the orderly shutdown
    # (The origin unit is ms, hence the conversion)
    timewait=$((OCF_RESKEY_CRM_meta_timeout/1500))

    sleep 1; timeout=0 # Sleep here for 1 sec to let dhcpd finish.
    while dhcpd_monitor ; do
        if [ $timeout -ge $timewait ]; then
            break
        else
            sleep 1
            timeout=`expr $timeout + 1`
#            ocf_log debug "dhcpd appears to hung, waiting ..."
        fi
    done

    #If still up
    if dhcpd_monitor 2>&1; then
        ocf_log err "dhcpd is still up! Killing"
        kill -s SIGKILL `cat ${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_pid}`
    fi

    # If we are running a dhcp server v4 or higher, unmount the proc partition.
    if [ ${DHCP_VERSION_MAJOR} -ge 4 ] ; then
	umount ${OCF_RESKEY_chrooted_path}/proc > /dev/null 2>&1
    fi

    rm -f ${OCF_RESKEY_chrooted_path}/${OCF_RESKEY_pid}
    return $OCF_SUCCESS
}

# Make sure meta-data and usage always succeed
case $__OCF_ACTION in
meta-data)      dhcpd_meta_data
                exit $OCF_SUCCESS
                ;;
validate-all)   dhcpd_validate_all
		exit $OCF_SUCCESS
		;;
usage|help)     dhcpd_usage
                exit $OCF_SUCCESS
                ;;
esac

# We need to initialize the dhcp environment if this is the first time
# this script has been run.
dhcpd_validate_all || ocf_log info "First execution of the service, initializing." && dhcpd_initialize_chroot
# Anything other than meta-data and usage must pass validation
dhcpd_validate_all || exit $?

# Translate each action into the appropriate function call
case $__OCF_ACTION in
meta-data)      dhcpd_meta_data;;
start)          dhcpd_start;;
stop)           dhcpd_stop;;
status|monitor) dhcpd_monitor;;
*)              dhcpd_usage
                exit $OCF_ERR_UNIMPLEMENTED
                ;;
esac
rc=$?

#ocf_log debug "Resource Agent Exit Status $rc"
# The resource agent may optionally log a debug message
#ocf_log debug "${OCF_RESOURCE_INSTANCE} $__OCF_ACTION returned $rc"
exit $rc
